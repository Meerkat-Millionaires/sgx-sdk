import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { LavaLamp } from "../target/types/lava_lamp";
import { Flux } from "../target/types/flux";

import fs from "fs";
import path from "path";
import {
  Mint,
  NativeMint,
  TransactionObject,
  parseMrEnclave,
} from "@switchboard-xyz/solana.js";
import { functionVerify } from "@switchboard-xyz/solana.js/generated/attestation/instructions";
import assert from "assert";
import {
  SwitchboardEnvironment,
  initializeSwitchboardEnvironment,
} from "./switchboard";

const unixTimestamp = () => Math.floor(Date.now() / 1000);

function getMrEnclave(): Buffer {
  const measurementTxtPath = path.join(
    __dirname,
    "..",
    "sgx-function",
    "measurement.txt"
  );
  if (!fs.existsSync(measurementTxtPath)) {
    throw new Error(
      `Failed to find measurement at ${path.relative(
        process.cwd(),
        measurementTxtPath
      )}`
    );
  }

  const measurement = fs.readFileSync(measurementTxtPath, "utf-8").trim();
  const buffer = Buffer.from(measurement, "base64");
  return buffer;
}

describe("lava lamp", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.AnchorProvider.env());

  const lavaLamp = anchor.workspace.LavaLamp as Program<LavaLamp>,
    lavaLampSeed = anchor.utils.bytes.utf8.encode("LAVALAMPSTATE");

  const flux = anchor.workspace.Flux as Program<LavaLamp>,
    fluxSeed = anchor.utils.bytes.utf8.encode("FLUXSTATE");

  const payer = (lavaLamp.provider as anchor.AnchorProvider).wallet.publicKey;

  const [lavaLampStatePubkey] = anchor.web3.PublicKey.findProgramAddressSync(
    [lavaLampSeed],
    lavaLamp.programId
  );
  const bufferKeypair = anchor.web3.Keypair.generate();

  const rewardAddress = anchor.utils.token.associatedAddress({
    mint: NativeMint.address,
    owner: lavaLampStatePubkey,
  });

  const mockMrEnclave = parseMrEnclave(
    Buffer.from("My custom function sgx measurement")
  );

  let switchboard: SwitchboardEnvironment;

  before(async () => {
    // Create function & quote account
    switchboard = await initializeSwitchboardEnvironment(
      lavaLamp.provider as anchor.AnchorProvider,
      mockMrEnclave
    );
  });

  it("Initialize the lava lamp state", async () => {
    const bufferSize = 10000;
    const sig = await lavaLamp.methods
      .initialize({ bufferSize: bufferSize, byteCost: new anchor.BN(0) })
      .accounts({
        buffer: bufferKeypair.publicKey,
        rewardAddress,
        mint: NativeMint.address,
        authority: lavaLamp.provider.publicKey!,
        payer: lavaLamp.provider.publicKey!,
        /// AUTO GENERATED BY ANCHOR

        // lavaLamp: lavaLampStatePubkey,
        // systemProgram: anchor.web3.SystemProgram.programId,
        // tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
        // associatedTokenProgram: anchor.utils.token.ASSOCIATED_PROGRAM_ID,
        // rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .signers([bufferKeypair])
      .rpc();

    const lavaLampState = await lavaLamp.account.lavaLampAccount.fetch(
      lavaLampStatePubkey
    );
    assert(lavaLampState.maxSize === bufferSize);
    const bufferAccountInfo = await lavaLamp.provider.connection.getAccountInfo(
      bufferKeypair.publicKey
    );
    assert(bufferAccountInfo.data.byteLength === bufferSize + 12);

    const buffer = bufferAccountInfo.data.slice(12);
    assert(buffer.every((v) => v === 0));
  });

  it("Bubbles some randomness to the buffer", async () => {
    const trustedSigner = anchor.web3.Keypair.generate();

    // TODO: generate function verify ixn
    const functionVerifyIxn = functionVerify(
      switchboard.attestationQueueAccount.program,
      {
        params: {
          observedTime: new anchor.BN(unixTimestamp()),
          nextAllowedTimestamp: new anchor.BN(unixTimestamp() + 100),
          isFailure: false,
          mrEnclave: Array.from(mockMrEnclave),
        },
      },
      {
        function: switchboard.functionAccount.publicKey,
        fnSigner: trustedSigner.publicKey,
        verifierQuote: switchboard.attestationQuoteVerifierAccount.publicKey,
        attestationQueue: switchboard.attestationQueueAccount.publicKey,
        escrow: switchboard.functionAccount.getEscrow(),
        receiver: rewardAddress,
        verifierPermission:
          switchboard.attestationQuoteVerifierAccount.getPermissionAccount(
            switchboard.attestationQueueAccount.publicKey,
            payer,
            payer
          )[0].publicKey,
        fnPermission: switchboard.functionAccount.getPermissionAccount(
          switchboard.attestationQueueAccount.publicKey,
          payer
        )[0].publicKey,
        state:
          switchboard.attestationQueueAccount.program.attestationProgramState
            .publicKey,
        payer: payer,
        fnQuote: switchboard.functionQuoteAccount.publicKey,
        tokenProgram: anchor.utils.token.TOKEN_PROGRAM_ID,
        systemProgram: anchor.web3.SystemProgram.programId,
      }
    );

    const madeUpTxn = new TransactionObject(
      payer,
      [functionVerifyIxn],
      [trustedSigner, switchboard.quoteVerifierKeypair]
    );
    const functionVerifyBuffer = madeUpTxn
      .toTxn(await lavaLamp.provider.connection.getLatestBlockhash())
      .compileMessage()
      .serialize();
    console.log(`functionVerify Bytes: ${functionVerifyBuffer.byteLength}`);

    const randomness = createRandomUint8Array();
    const sig = await lavaLamp.methods
      .bubble({ data: Buffer.from(randomness) })
      .accounts({
        buffer: bufferKeypair.publicKey,
        function: switchboard.functionAccount.publicKey,
        quote: switchboard.functionQuoteAccount.publicKey,
        securedSigner: trustedSigner.publicKey,
      })
      .preInstructions([functionVerifyIxn])
      .signers([trustedSigner, switchboard.quoteVerifierKeypair])
      .rpc()
      .catch((err) => {
        console.error(err);
        throw err;
      });

    console.log(sig);

    const bufferAccountInfo = await lavaLamp.provider.connection.getAccountInfo(
      bufferKeypair.publicKey
    );

    const buffer = bufferAccountInfo.data.slice(12);

    console.log(`EXPECTED:\n[${randomness}]`);
    console.log(`RECEIVED:\n[${new Uint8Array(buffer.slice(0, 250))}]`);

    assert(
      Buffer.compare(
        Buffer.from(buffer.slice(0, 250)),
        Buffer.from(randomness)
      ) === 0,
      "DidNotWriteRandomness"
    );

    // const bufferState = lavaLamp.coder.accounts.decode(
    //   "BufferAccount",
    //   bufferAccountInfo.data
    // );

    // const view = new DataView(new Uint8Array(bufferAccountInfo.data), 8, 4);
    // const writeIdx = view.getUint32(0, true);
    const writeIdx = bufferAccountInfo.data.readUInt32LE(8);

    console.log(`WriteIdx: ${writeIdx}`);

    assert(writeIdx === 250, "WriteIdxMismatch");
  });
});

function createRandomUint8Array(size = 250) {
  let arr = new Uint8Array(size);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = Math.floor(Math.random() * 256);
  }
  return arr;
}
